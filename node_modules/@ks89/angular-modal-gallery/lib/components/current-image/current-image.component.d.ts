import { AfterContentInit, ChangeDetectorRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';
import { AccessibleComponent } from '../accessible.component';
import { AccessibilityConfig } from '../../model/accessibility.interface';
import { Action } from '../../model/action.enum';
import { Image, ImageModalEvent } from '../../model/image.class';
import { InternalLibImage } from '../../model/image-internal.class';
import { KeyboardConfig } from '../../model/keyboard-config.interface';
import { SlideConfig } from '../../model/slide-config.interface';
import { CurrentImageConfig } from '../../model/current-image-config.interface';
/**
 * Interface to describe the Load Event, used to
 * emit an event when the image is finally loaded and the spinner has gone.
 */
import * as ɵngcc0 from '@angular/core';
export interface ImageLoadEvent {
    status: boolean;
    index: number;
    id: number;
}
/**
 * Component with the current image with some additional elements like arrows and side previews.
 */
export declare class CurrentImageComponent extends AccessibleComponent implements OnInit, OnChanges, AfterContentInit, OnDestroy {
    private _platformId;
    private _ngZone;
    private ref;
    /**
     * Unique id (>=0) of the current instance of this library. This is useful when you are using
     * the service to call modal gallery without open it manually.
     */
    id: number;
    /**
     * Object of type `InternalLibImage` that represent the visible image.
     */
    currentImage: InternalLibImage;
    /**
     * Array of `InternalLibImage` that represent the model of this library with all images,
     * thumbs and so on.
     */
    images: InternalLibImage[];
    /**
     * Boolean that it is true if the modal gallery is visible.
     * If yes, also this component should be visible.
     */
    isOpen: boolean;
    /**
     * Interface to configure current image in modal-gallery.
     * For instance you can disable navigation on click on current image (enabled by default).
     */
    currentImageConfig: CurrentImageConfig;
    /**
     * Object of type `SlideConfig` to get `infinite sliding`.
     */
    slideConfig: SlideConfig;
    /**
     * Object of type `AccessibilityConfig` to init custom accessibility features.
     * For instance, it contains titles, alt texts, aria-labels and so on.
     */
    accessibilityConfig: AccessibilityConfig;
    /**
     * Object of type `KeyboardConfig` to assign custom keys to both ESC, RIGHT and LEFT keyboard's actions.
     */
    keyboardConfig: KeyboardConfig;
    /**
     * Output to emit an event when images are loaded. The payload contains an `ImageLoadEvent`.
     */
    loadImage: EventEmitter<ImageLoadEvent>;
    /**
     * Output to emit any changes of the current image. The payload contains an `ImageModalEvent`.
     */
    changeImage: EventEmitter<ImageModalEvent>;
    /**
     * Output to emit an event when the modal gallery is closed. The payload contains an `ImageModalEvent`.
     */
    close: EventEmitter<ImageModalEvent>;
    /**
     * Subject to play modal-gallery.
     */
    private start$;
    /**
     * Subject to stop modal-gallery.
     */
    private stop$;
    /**
     * Enum of type `Action` that represents a normal action.
     * Declared here to be used inside the template.
     */
    normalAction: Action;
    /**
     * Enum of type `Action` that represents a mouse click on a button.
     * Declared here to be used inside the template.
     */
    clickAction: Action;
    /**
     * Enum of type `Action` that represents a keyboard action.
     * Declared here to be used inside the template.
     */
    keyboardAction: Action;
    /**
     * Boolean that it's true when you are watching the first image (currently visible).
     * False by default
     */
    isFirstImage: boolean;
    /**
     * Boolean that it's true when you are watching the last image (currently visible).
     * False by default
     */
    isLastImage: boolean;
    /**
     * Boolean that it's true if an image of the modal gallery is still loading.
     * True by default
     */
    loading: boolean;
    /**
     * Object of type `CurrentImageConfig` exposed to the template. This field is initialized
     * applying transformations, default values and so on to the input of the same type.
     */
    configCurrentImage: CurrentImageConfig;
    configSlide: SlideConfig;
    /**
     * Private object without type to define all swipe actions used by hammerjs.
     */
    private SWIPE_ACTION;
    constructor(_platformId: any, _ngZone: NgZone, ref: ChangeDetectorRef);
    /**
     * Listener to stop the gallery when the mouse pointer is over the current image.
     */
    onMouseEnter(): void;
    /**
     * Listener to play the gallery when the mouse pointer leave the current image.
     */
    onMouseLeave(): void;
    /**
     * Method ´ngOnInit´ to build `configCurrentImage` applying default values.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called only one time!!!
     */
    ngOnInit(): void;
    /**
     * Method ´ngOnChanges´ to update `loading` status and emit events.
     * If the gallery is open, then it will also manage boundary arrows and sliding.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called when any data-bound property of a directive changes!!!
     */
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterContentInit(): void;
    /**
     * Method to handle keypress based on the `keyboardConfig` input. It gets the keyCode of
     * the key that triggered the keypress event to navigate between images or to close the modal gallery.
     * @param number keyCode of the key that triggered the keypress event
     */
    onKeyPress(keyCode: number): void;
    /**
     * Method to get the image description based on input params.
     * If you provide a full description this will be the visible description, otherwise,
     * it will be built using the `Description` object, concatenating its fields.
     * @param Image image to get its description. If not provided it will be the current image
     * @returns String description of the image (or the current image if not provided)
     * @throws an Error if description isn't available
     */
    getDescriptionToDisplay(image?: Image): string;
    /**
     * Method to get `alt attribute`.
     * `alt` specifies an alternate text for an image, if the image cannot be displayed.
     * @param Image image to get its alt description. If not provided it will be the current image
     * @returns String alt description of the image (or the current image if not provided)
     */
    getAltDescriptionByImage(image?: Image): string;
    /**
     * Method to get the title attributes based on descriptions.
     * This is useful to prevent accessibility issues, because if DescriptionStrategy is ALWAYS_HIDDEN,
     * it prevents an empty string as title.
     * @param Image image to get its description. If not provided it will be the current image
     * @returns String title of the image based on descriptions
     * @throws an Error if description isn't available
     */
    getTitleToDisplay(image?: Image): string;
    /**
     * Method to get the left side preview image.
     * @returns Image the image to show as size preview on the left
     */
    getLeftPreviewImage(): Image;
    /**
     * Method to get the right side preview image.
     * @returns Image the image to show as size preview on the right
     */
    getRightPreviewImage(): Image;
    /**
     * Method called by events from both keyboard and mouse on an image.
     * This will invoke the nextImage method.
     * @param KeyboardEvent | MouseEvent event payload
     * @param Action action that triggered the event or `Action.NORMAL` if not provided
     */
    onImageEvent(event: KeyboardEvent | MouseEvent, action?: Action): void;
    /**
     * Method called by events from both keyboard and mouse on a navigation arrow.
     * @param string direction of the navigation that can be either 'next' or 'prev'
     * @param KeyboardEvent | MouseEvent event payload
     * @param Action action that triggered the event or `Action.NORMAL` if not provided
     * @param boolean disable to disable navigation
     */
    onNavigationEvent(direction: string, event: KeyboardEvent, action?: Action, disable?: boolean): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved back to the previous image. `Action.NORMAL` by default.
     */
    prevImage(action?: Action): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved to the next image. `Action.NORMAL` by default.
     */
    nextImage(action?: Action): void;
    /**
     * Method to emit an event as loadImage output to say that the requested image if loaded.
     * This method is invoked by the javascript's 'load' event on an img tag.
     * @param Event event that triggered the load
     */
    onImageLoad(event: Event): void;
    /**
     * Method used by Hammerjs to support touch gestures (you can also invert the swipe direction with configCurrentImage.invertSwipe).
     * @param action String that represent the direction of the swipe action. 'swiperight' by default.
     */
    swipe(action?: string): void;
    /**
     * Method used in `modal-gallery.component` to get the index of an image to delete.
     * @param Image image to get the index, or the visible image, if not passed
     * @returns number the index of the image
     */
    getIndexToDelete(image?: Image): number;
    /**
     * Method to play modal gallery.
     */
    playCarousel(): void;
    /**
     * Stops modal gallery from cycling through items.
     */
    stopCarousel(): void;
    /**
     * Method to cleanup resources. In fact, this will stop the modal gallery.
     * This is an Angular's lifecycle hook that is called when this component is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Private method to update both `isFirstImage` and `isLastImage` based on
     * the index of the current image.
     * @param number currentIndex is the index of the current image
     */
    private handleBoundaries;
    /**
     * Private method to check if next/prev actions should be blocked.
     * It checks if configSlide.infinite === false and if the image index is equals to the input parameter.
     * If yes, it returns true to say that sliding should be blocked, otherwise not.
     * @param number boundaryIndex that could be either the beginning index (0) or the last index
     *  of images (this.images.length - 1).
     * @returns boolean true if configSlide.infinite === false and the current index is
     *  either the first or the last one.
     */
    private isPreventSliding;
    /**
     * Private method to get the next index.
     * This is necessary because at the end, when you call next again, you'll go to the first image.
     * That happens because all modal images are shown like in a circle.
     */
    private getNextImage;
    /**
     * Private method to get the previous index.
     * This is necessary because at index 0, when you call prev again, you'll go to the last image.
     * That happens because all modal images are shown like in a circle.
     */
    private getPrevImage;
    /**
     * Private method to build a text description.
     * This is used also to create titles.
     * @param Image image to get its description. If not provided it will be the current image.
     * @param boolean imageWithoutDescription is a boolean that it's true if the image hasn't a 'modal' description.
     * @returns String description built concatenating image fields with a specific logic.
     */
    private buildTextDescription;
    /**
     * Private method to call handleBoundaries when ngOnChanges is called.
     */
    private updateIndexes;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CurrentImageComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CurrentImageComponent, "ks-current-image", never, { "id": "id"; "currentImage": "currentImage"; "images": "images"; "isOpen": "isOpen"; "currentImageConfig": "currentImageConfig"; "slideConfig": "slideConfig"; "accessibilityConfig": "accessibilityConfig"; "keyboardConfig": "keyboardConfig"; }, { "loadImage": "loadImage"; "changeImage": "changeImage"; "close": "close"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY2Nlc3NpYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vYWNjZXNzaWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWNjZXNzaWJpbGl0eUNvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2FjY2Vzc2liaWxpdHkuaW50ZXJmYWNlJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVsL2FjdGlvbi5lbnVtJztcbmltcG9ydCB7IEltYWdlLCBJbWFnZU1vZGFsRXZlbnQgfSBmcm9tICcuLi8uLi9tb2RlbC9pbWFnZS5jbGFzcyc7XG5pbXBvcnQgeyBJbnRlcm5hbExpYkltYWdlIH0gZnJvbSAnLi4vLi4vbW9kZWwvaW1hZ2UtaW50ZXJuYWwuY2xhc3MnO1xuaW1wb3J0IHsgS2V5Ym9hcmRDb25maWcgfSBmcm9tICcuLi8uLi9tb2RlbC9rZXlib2FyZC1jb25maWcuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNsaWRlQ29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvc2xpZGUtY29uZmlnLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXJyZW50SW1hZ2VDb25maWcgfSBmcm9tICcuLi8uLi9tb2RlbC9jdXJyZW50LWltYWdlLWNvbmZpZy5pbnRlcmZhY2UnO1xuLyoqXG4gKiBJbnRlcmZhY2UgdG8gZGVzY3JpYmUgdGhlIExvYWQgRXZlbnQsIHVzZWQgdG9cbiAqIGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgaW1hZ2UgaXMgZmluYWxseSBsb2FkZWQgYW5kIHRoZSBzcGlubmVyIGhhcyBnb25lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlTG9hZEV2ZW50IHtcbiAgICBzdGF0dXM6IGJvb2xlYW47XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBpZDogbnVtYmVyO1xufVxuLyoqXG4gKiBDb21wb25lbnQgd2l0aCB0aGUgY3VycmVudCBpbWFnZSB3aXRoIHNvbWUgYWRkaXRpb25hbCBlbGVtZW50cyBsaWtlIGFycm93cyBhbmQgc2lkZSBwcmV2aWV3cy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ3VycmVudEltYWdlQ29tcG9uZW50IGV4dGVuZHMgQWNjZXNzaWJsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX3BsYXRmb3JtSWQ7XG4gICAgcHJpdmF0ZSBfbmdab25lO1xuICAgIHByaXZhdGUgcmVmO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBpZCAoPj0wKSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGxpYnJhcnkuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGFyZSB1c2luZ1xuICAgICAqIHRoZSBzZXJ2aWNlIHRvIGNhbGwgbW9kYWwgZ2FsbGVyeSB3aXRob3V0IG9wZW4gaXQgbWFudWFsbHkuXG4gICAgICovXG4gICAgaWQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgSW50ZXJuYWxMaWJJbWFnZWAgdGhhdCByZXByZXNlbnQgdGhlIHZpc2libGUgaW1hZ2UuXG4gICAgICovXG4gICAgY3VycmVudEltYWdlOiBJbnRlcm5hbExpYkltYWdlO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGBJbnRlcm5hbExpYkltYWdlYCB0aGF0IHJlcHJlc2VudCB0aGUgbW9kZWwgb2YgdGhpcyBsaWJyYXJ5IHdpdGggYWxsIGltYWdlcyxcbiAgICAgKiB0aHVtYnMgYW5kIHNvIG9uLlxuICAgICAqL1xuICAgIGltYWdlczogSW50ZXJuYWxMaWJJbWFnZVtdO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gdGhhdCBpdCBpcyB0cnVlIGlmIHRoZSBtb2RhbCBnYWxsZXJ5IGlzIHZpc2libGUuXG4gICAgICogSWYgeWVzLCBhbHNvIHRoaXMgY29tcG9uZW50IHNob3VsZCBiZSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzT3BlbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdG8gY29uZmlndXJlIGN1cnJlbnQgaW1hZ2UgaW4gbW9kYWwtZ2FsbGVyeS5cbiAgICAgKiBGb3IgaW5zdGFuY2UgeW91IGNhbiBkaXNhYmxlIG5hdmlnYXRpb24gb24gY2xpY2sgb24gY3VycmVudCBpbWFnZSAoZW5hYmxlZCBieSBkZWZhdWx0KS5cbiAgICAgKi9cbiAgICBjdXJyZW50SW1hZ2VDb25maWc6IEN1cnJlbnRJbWFnZUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgU2xpZGVDb25maWdgIHRvIGdldCBgaW5maW5pdGUgc2xpZGluZ2AuXG4gICAgICovXG4gICAgc2xpZGVDb25maWc6IFNsaWRlQ29uZmlnO1xuICAgIC8qKlxuICAgICAqIE9iamVjdCBvZiB0eXBlIGBBY2Nlc3NpYmlsaXR5Q29uZmlnYCB0byBpbml0IGN1c3RvbSBhY2Nlc3NpYmlsaXR5IGZlYXR1cmVzLlxuICAgICAqIEZvciBpbnN0YW5jZSwgaXQgY29udGFpbnMgdGl0bGVzLCBhbHQgdGV4dHMsIGFyaWEtbGFiZWxzIGFuZCBzbyBvbi5cbiAgICAgKi9cbiAgICBhY2Nlc3NpYmlsaXR5Q29uZmlnOiBBY2Nlc3NpYmlsaXR5Q29uZmlnO1xuICAgIC8qKlxuICAgICAqIE9iamVjdCBvZiB0eXBlIGBLZXlib2FyZENvbmZpZ2AgdG8gYXNzaWduIGN1c3RvbSBrZXlzIHRvIGJvdGggRVNDLCBSSUdIVCBhbmQgTEVGVCBrZXlib2FyZCdzIGFjdGlvbnMuXG4gICAgICovXG4gICAga2V5Ym9hcmRDb25maWc6IEtleWJvYXJkQ29uZmlnO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCB0byBlbWl0IGFuIGV2ZW50IHdoZW4gaW1hZ2VzIGFyZSBsb2FkZWQuIFRoZSBwYXlsb2FkIGNvbnRhaW5zIGFuIGBJbWFnZUxvYWRFdmVudGAuXG4gICAgICovXG4gICAgbG9hZEltYWdlOiBFdmVudEVtaXR0ZXI8SW1hZ2VMb2FkRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIE91dHB1dCB0byBlbWl0IGFueSBjaGFuZ2VzIG9mIHRoZSBjdXJyZW50IGltYWdlLiBUaGUgcGF5bG9hZCBjb250YWlucyBhbiBgSW1hZ2VNb2RhbEV2ZW50YC5cbiAgICAgKi9cbiAgICBjaGFuZ2VJbWFnZTogRXZlbnRFbWl0dGVyPEltYWdlTW9kYWxFdmVudD47XG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRvIGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgbW9kYWwgZ2FsbGVyeSBpcyBjbG9zZWQuIFRoZSBwYXlsb2FkIGNvbnRhaW5zIGFuIGBJbWFnZU1vZGFsRXZlbnRgLlxuICAgICAqL1xuICAgIGNsb3NlOiBFdmVudEVtaXR0ZXI8SW1hZ2VNb2RhbEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBTdWJqZWN0IHRvIHBsYXkgbW9kYWwtZ2FsbGVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXJ0JDtcbiAgICAvKipcbiAgICAgKiBTdWJqZWN0IHRvIHN0b3AgbW9kYWwtZ2FsbGVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0b3AkO1xuICAgIC8qKlxuICAgICAqIEVudW0gb2YgdHlwZSBgQWN0aW9uYCB0aGF0IHJlcHJlc2VudHMgYSBub3JtYWwgYWN0aW9uLlxuICAgICAqIERlY2xhcmVkIGhlcmUgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIG5vcm1hbEFjdGlvbjogQWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEVudW0gb2YgdHlwZSBgQWN0aW9uYCB0aGF0IHJlcHJlc2VudHMgYSBtb3VzZSBjbGljayBvbiBhIGJ1dHRvbi5cbiAgICAgKiBEZWNsYXJlZCBoZXJlIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBjbGlja0FjdGlvbjogQWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEVudW0gb2YgdHlwZSBgQWN0aW9uYCB0aGF0IHJlcHJlc2VudHMgYSBrZXlib2FyZCBhY3Rpb24uXG4gICAgICogRGVjbGFyZWQgaGVyZSB0byBiZSB1c2VkIGluc2lkZSB0aGUgdGVtcGxhdGUuXG4gICAgICovXG4gICAga2V5Ym9hcmRBY3Rpb246IEFjdGlvbjtcbiAgICAvKipcbiAgICAgKiBCb29sZWFuIHRoYXQgaXQncyB0cnVlIHdoZW4geW91IGFyZSB3YXRjaGluZyB0aGUgZmlyc3QgaW1hZ2UgKGN1cnJlbnRseSB2aXNpYmxlKS5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgaXNGaXJzdEltYWdlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gdGhhdCBpdCdzIHRydWUgd2hlbiB5b3UgYXJlIHdhdGNoaW5nIHRoZSBsYXN0IGltYWdlIChjdXJyZW50bHkgdmlzaWJsZSkuXG4gICAgICogRmFsc2UgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGlzTGFzdEltYWdlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gdGhhdCBpdCdzIHRydWUgaWYgYW4gaW1hZ2Ugb2YgdGhlIG1vZGFsIGdhbGxlcnkgaXMgc3RpbGwgbG9hZGluZy5cbiAgICAgKiBUcnVlIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2FkaW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIE9iamVjdCBvZiB0eXBlIGBDdXJyZW50SW1hZ2VDb25maWdgIGV4cG9zZWQgdG8gdGhlIHRlbXBsYXRlLiBUaGlzIGZpZWxkIGlzIGluaXRpYWxpemVkXG4gICAgICogYXBwbHlpbmcgdHJhbnNmb3JtYXRpb25zLCBkZWZhdWx0IHZhbHVlcyBhbmQgc28gb24gdG8gdGhlIGlucHV0IG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgICovXG4gICAgY29uZmlnQ3VycmVudEltYWdlOiBDdXJyZW50SW1hZ2VDb25maWc7XG4gICAgY29uZmlnU2xpZGU6IFNsaWRlQ29uZmlnO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgb2JqZWN0IHdpdGhvdXQgdHlwZSB0byBkZWZpbmUgYWxsIHN3aXBlIGFjdGlvbnMgdXNlZCBieSBoYW1tZXJqcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIFNXSVBFX0FDVElPTjtcbiAgICBjb25zdHJ1Y3RvcihfcGxhdGZvcm1JZDogYW55LCBfbmdab25lOiBOZ1pvbmUsIHJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHN0b3AgdGhlIGdhbGxlcnkgd2hlbiB0aGUgbW91c2UgcG9pbnRlciBpcyBvdmVyIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAqL1xuICAgIG9uTW91c2VFbnRlcigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIExpc3RlbmVyIHRvIHBsYXkgdGhlIGdhbGxlcnkgd2hlbiB0aGUgbW91c2UgcG9pbnRlciBsZWF2ZSB0aGUgY3VycmVudCBpbWFnZS5cbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgwrRuZ09uSW5pdMK0IHRvIGJ1aWxkIGBjb25maWdDdXJyZW50SW1hZ2VgIGFwcGx5aW5nIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgYW4gQW5ndWxhcidzIGxpZmVjeWNsZSBob29rLCBzbyBpdHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQW5ndWxhciBpdHNlbGYuXG4gICAgICogSW4gcGFydGljdWxhciwgaXQncyBjYWxsZWQgb25seSBvbmUgdGltZSEhIVxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIMK0bmdPbkNoYW5nZXPCtCB0byB1cGRhdGUgYGxvYWRpbmdgIHN0YXR1cyBhbmQgZW1pdCBldmVudHMuXG4gICAgICogSWYgdGhlIGdhbGxlcnkgaXMgb3BlbiwgdGhlbiBpdCB3aWxsIGFsc28gbWFuYWdlIGJvdW5kYXJ5IGFycm93cyBhbmQgc2xpZGluZy5cbiAgICAgKiBUaGlzIGlzIGFuIEFuZ3VsYXIncyBsaWZlY3ljbGUgaG9vaywgc28gaXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IEFuZ3VsYXIgaXRzZWxmLlxuICAgICAqIEluIHBhcnRpY3VsYXIsIGl0J3MgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcyEhIVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBoYW5kbGUga2V5cHJlc3MgYmFzZWQgb24gdGhlIGBrZXlib2FyZENvbmZpZ2AgaW5wdXQuIEl0IGdldHMgdGhlIGtleUNvZGUgb2ZcbiAgICAgKiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBrZXlwcmVzcyBldmVudCB0byBuYXZpZ2F0ZSBiZXR3ZWVuIGltYWdlcyBvciB0byBjbG9zZSB0aGUgbW9kYWwgZ2FsbGVyeS5cbiAgICAgKiBAcGFyYW0gbnVtYmVyIGtleUNvZGUgb2YgdGhlIGtleSB0aGF0IHRyaWdnZXJlZCB0aGUga2V5cHJlc3MgZXZlbnRcbiAgICAgKi9cbiAgICBvbktleVByZXNzKGtleUNvZGU6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCB0aGUgaW1hZ2UgZGVzY3JpcHRpb24gYmFzZWQgb24gaW5wdXQgcGFyYW1zLlxuICAgICAqIElmIHlvdSBwcm92aWRlIGEgZnVsbCBkZXNjcmlwdGlvbiB0aGlzIHdpbGwgYmUgdGhlIHZpc2libGUgZGVzY3JpcHRpb24sIG90aGVyd2lzZSxcbiAgICAgKiBpdCB3aWxsIGJlIGJ1aWx0IHVzaW5nIHRoZSBgRGVzY3JpcHRpb25gIG9iamVjdCwgY29uY2F0ZW5hdGluZyBpdHMgZmllbGRzLlxuICAgICAqIEBwYXJhbSBJbWFnZSBpbWFnZSB0byBnZXQgaXRzIGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFN0cmluZyBkZXNjcmlwdGlvbiBvZiB0aGUgaW1hZ2UgKG9yIHRoZSBjdXJyZW50IGltYWdlIGlmIG5vdCBwcm92aWRlZClcbiAgICAgKiBAdGhyb3dzIGFuIEVycm9yIGlmIGRlc2NyaXB0aW9uIGlzbid0IGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGdldERlc2NyaXB0aW9uVG9EaXNwbGF5KGltYWdlPzogSW1hZ2UpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCBgYWx0IGF0dHJpYnV0ZWAuXG4gICAgICogYGFsdGAgc3BlY2lmaWVzIGFuIGFsdGVybmF0ZSB0ZXh0IGZvciBhbiBpbWFnZSwgaWYgdGhlIGltYWdlIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXG4gICAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCBpdHMgYWx0IGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFN0cmluZyBhbHQgZGVzY3JpcHRpb24gb2YgdGhlIGltYWdlIChvciB0aGUgY3VycmVudCBpbWFnZSBpZiBub3QgcHJvdmlkZWQpXG4gICAgICovXG4gICAgZ2V0QWx0RGVzY3JpcHRpb25CeUltYWdlKGltYWdlPzogSW1hZ2UpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCB0aGUgdGl0bGUgYXR0cmlidXRlcyBiYXNlZCBvbiBkZXNjcmlwdGlvbnMuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gcHJldmVudCBhY2Nlc3NpYmlsaXR5IGlzc3VlcywgYmVjYXVzZSBpZiBEZXNjcmlwdGlvblN0cmF0ZWd5IGlzIEFMV0FZU19ISURERU4sXG4gICAgICogaXQgcHJldmVudHMgYW4gZW1wdHkgc3RyaW5nIGFzIHRpdGxlLlxuICAgICAqIEBwYXJhbSBJbWFnZSBpbWFnZSB0byBnZXQgaXRzIGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFN0cmluZyB0aXRsZSBvZiB0aGUgaW1hZ2UgYmFzZWQgb24gZGVzY3JpcHRpb25zXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBkZXNjcmlwdGlvbiBpc24ndCBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXRUaXRsZVRvRGlzcGxheShpbWFnZT86IEltYWdlKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIGxlZnQgc2lkZSBwcmV2aWV3IGltYWdlLlxuICAgICAqIEByZXR1cm5zIEltYWdlIHRoZSBpbWFnZSB0byBzaG93IGFzIHNpemUgcHJldmlldyBvbiB0aGUgbGVmdFxuICAgICAqL1xuICAgIGdldExlZnRQcmV2aWV3SW1hZ2UoKTogSW1hZ2U7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCB0aGUgcmlnaHQgc2lkZSBwcmV2aWV3IGltYWdlLlxuICAgICAqIEByZXR1cm5zIEltYWdlIHRoZSBpbWFnZSB0byBzaG93IGFzIHNpemUgcHJldmlldyBvbiB0aGUgcmlnaHRcbiAgICAgKi9cbiAgICBnZXRSaWdodFByZXZpZXdJbWFnZSgpOiBJbWFnZTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIGJ5IGV2ZW50cyBmcm9tIGJvdGgga2V5Ym9hcmQgYW5kIG1vdXNlIG9uIGFuIGltYWdlLlxuICAgICAqIFRoaXMgd2lsbCBpbnZva2UgdGhlIG5leHRJbWFnZSBtZXRob2QuXG4gICAgICogQHBhcmFtIEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50IGV2ZW50IHBheWxvYWRcbiAgICAgKiBAcGFyYW0gQWN0aW9uIGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQgb3IgYEFjdGlvbi5OT1JNQUxgIGlmIG5vdCBwcm92aWRlZFxuICAgICAqL1xuICAgIG9uSW1hZ2VFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQsIGFjdGlvbj86IEFjdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCBieSBldmVudHMgZnJvbSBib3RoIGtleWJvYXJkIGFuZCBtb3VzZSBvbiBhIG5hdmlnYXRpb24gYXJyb3cuXG4gICAgICogQHBhcmFtIHN0cmluZyBkaXJlY3Rpb24gb2YgdGhlIG5hdmlnYXRpb24gdGhhdCBjYW4gYmUgZWl0aGVyICduZXh0JyBvciAncHJldidcbiAgICAgKiBAcGFyYW0gS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQgZXZlbnQgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBBY3Rpb24gYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBldmVudCBvciBgQWN0aW9uLk5PUk1BTGAgaWYgbm90IHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGJvb2xlYW4gZGlzYWJsZSB0byBkaXNhYmxlIG5hdmlnYXRpb25cbiAgICAgKi9cbiAgICBvbk5hdmlnYXRpb25FdmVudChkaXJlY3Rpb246IHN0cmluZywgZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGFjdGlvbj86IEFjdGlvbiwgZGlzYWJsZT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBpbWFnZS5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIEVudW0gb2YgdHlwZSBgQWN0aW9uYCB0aGF0IHJlcHJlc2VudHMgdGhlIHNvdXJjZVxuICAgICAqICBhY3Rpb24gdGhhdCBtb3ZlZCBiYWNrIHRvIHRoZSBwcmV2aW91cyBpbWFnZS4gYEFjdGlvbi5OT1JNQUxgIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgcHJldkltYWdlKGFjdGlvbj86IEFjdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdvIGJhY2sgdG8gdGhlIHByZXZpb3VzIGltYWdlLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyB0aGUgc291cmNlXG4gICAgICogIGFjdGlvbiB0aGF0IG1vdmVkIHRvIHRoZSBuZXh0IGltYWdlLiBgQWN0aW9uLk5PUk1BTGAgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBuZXh0SW1hZ2UoYWN0aW9uPzogQWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZW1pdCBhbiBldmVudCBhcyBsb2FkSW1hZ2Ugb3V0cHV0IHRvIHNheSB0aGF0IHRoZSByZXF1ZXN0ZWQgaW1hZ2UgaWYgbG9hZGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYnkgdGhlIGphdmFzY3JpcHQncyAnbG9hZCcgZXZlbnQgb24gYW4gaW1nIHRhZy5cbiAgICAgKiBAcGFyYW0gRXZlbnQgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIGxvYWRcbiAgICAgKi9cbiAgICBvbkltYWdlTG9hZChldmVudDogRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIGJ5IEhhbW1lcmpzIHRvIHN1cHBvcnQgdG91Y2ggZ2VzdHVyZXMgKHlvdSBjYW4gYWxzbyBpbnZlcnQgdGhlIHN3aXBlIGRpcmVjdGlvbiB3aXRoIGNvbmZpZ0N1cnJlbnRJbWFnZS5pbnZlcnRTd2lwZSkuXG4gICAgICogQHBhcmFtIGFjdGlvbiBTdHJpbmcgdGhhdCByZXByZXNlbnQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3dpcGUgYWN0aW9uLiAnc3dpcGVyaWdodCcgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBzd2lwZShhY3Rpb24/OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIGluIGBtb2RhbC1nYWxsZXJ5LmNvbXBvbmVudGAgdG8gZ2V0IHRoZSBpbmRleCBvZiBhbiBpbWFnZSB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCB0aGUgaW5kZXgsIG9yIHRoZSB2aXNpYmxlIGltYWdlLCBpZiBub3QgcGFzc2VkXG4gICAgICogQHJldHVybnMgbnVtYmVyIHRoZSBpbmRleCBvZiB0aGUgaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRJbmRleFRvRGVsZXRlKGltYWdlPzogSW1hZ2UpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHBsYXkgbW9kYWwgZ2FsbGVyeS5cbiAgICAgKi9cbiAgICBwbGF5Q2Fyb3VzZWwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBtb2RhbCBnYWxsZXJ5IGZyb20gY3ljbGluZyB0aHJvdWdoIGl0ZW1zLlxuICAgICAqL1xuICAgIHN0b3BDYXJvdXNlbCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBjbGVhbnVwIHJlc291cmNlcy4gSW4gZmFjdCwgdGhpcyB3aWxsIHN0b3AgdGhlIG1vZGFsIGdhbGxlcnkuXG4gICAgICogVGhpcyBpcyBhbiBBbmd1bGFyJ3MgbGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byB1cGRhdGUgYm90aCBgaXNGaXJzdEltYWdlYCBhbmQgYGlzTGFzdEltYWdlYCBiYXNlZCBvblxuICAgICAqIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpbWFnZS5cbiAgICAgKiBAcGFyYW0gbnVtYmVyIGN1cnJlbnRJbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUJvdW5kYXJpZXM7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gY2hlY2sgaWYgbmV4dC9wcmV2IGFjdGlvbnMgc2hvdWxkIGJlIGJsb2NrZWQuXG4gICAgICogSXQgY2hlY2tzIGlmIGNvbmZpZ1NsaWRlLmluZmluaXRlID09PSBmYWxzZSBhbmQgaWYgdGhlIGltYWdlIGluZGV4IGlzIGVxdWFscyB0byB0aGUgaW5wdXQgcGFyYW1ldGVyLlxuICAgICAqIElmIHllcywgaXQgcmV0dXJucyB0cnVlIHRvIHNheSB0aGF0IHNsaWRpbmcgc2hvdWxkIGJlIGJsb2NrZWQsIG90aGVyd2lzZSBub3QuXG4gICAgICogQHBhcmFtIG51bWJlciBib3VuZGFyeUluZGV4IHRoYXQgY291bGQgYmUgZWl0aGVyIHRoZSBiZWdpbm5pbmcgaW5kZXggKDApIG9yIHRoZSBsYXN0IGluZGV4XG4gICAgICogIG9mIGltYWdlcyAodGhpcy5pbWFnZXMubGVuZ3RoIC0gMSkuXG4gICAgICogQHJldHVybnMgYm9vbGVhbiB0cnVlIGlmIGNvbmZpZ1NsaWRlLmluZmluaXRlID09PSBmYWxzZSBhbmQgdGhlIGN1cnJlbnQgaW5kZXggaXNcbiAgICAgKiAgZWl0aGVyIHRoZSBmaXJzdCBvciB0aGUgbGFzdCBvbmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1ByZXZlbnRTbGlkaW5nO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIGdldCB0aGUgbmV4dCBpbmRleC5cbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGF0IHRoZSBlbmQsIHdoZW4geW91IGNhbGwgbmV4dCBhZ2FpbiwgeW91J2xsIGdvIHRvIHRoZSBmaXJzdCBpbWFnZS5cbiAgICAgKiBUaGF0IGhhcHBlbnMgYmVjYXVzZSBhbGwgbW9kYWwgaW1hZ2VzIGFyZSBzaG93biBsaWtlIGluIGEgY2lyY2xlLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dEltYWdlO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIGdldCB0aGUgcHJldmlvdXMgaW5kZXguXG4gICAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhdCBpbmRleCAwLCB3aGVuIHlvdSBjYWxsIHByZXYgYWdhaW4sIHlvdSdsbCBnbyB0byB0aGUgbGFzdCBpbWFnZS5cbiAgICAgKiBUaGF0IGhhcHBlbnMgYmVjYXVzZSBhbGwgbW9kYWwgaW1hZ2VzIGFyZSBzaG93biBsaWtlIGluIGEgY2lyY2xlLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UHJldkltYWdlO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIGJ1aWxkIGEgdGV4dCBkZXNjcmlwdGlvbi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgYWxzbyB0byBjcmVhdGUgdGl0bGVzLlxuICAgICAqIEBwYXJhbSBJbWFnZSBpbWFnZSB0byBnZXQgaXRzIGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZS5cbiAgICAgKiBAcGFyYW0gYm9vbGVhbiBpbWFnZVdpdGhvdXREZXNjcmlwdGlvbiBpcyBhIGJvb2xlYW4gdGhhdCBpdCdzIHRydWUgaWYgdGhlIGltYWdlIGhhc24ndCBhICdtb2RhbCcgZGVzY3JpcHRpb24uXG4gICAgICogQHJldHVybnMgU3RyaW5nIGRlc2NyaXB0aW9uIGJ1aWx0IGNvbmNhdGVuYXRpbmcgaW1hZ2UgZmllbGRzIHdpdGggYSBzcGVjaWZpYyBsb2dpYy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJ1aWxkVGV4dERlc2NyaXB0aW9uO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgaGFuZGxlQm91bmRhcmllcyB3aGVuIG5nT25DaGFuZ2VzIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUluZGV4ZXM7XG59XG4iXX0=